<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ECMAScript基础之promise chain | 苏进取</title>
<meta name="description" content="凝视深渊" />
<link rel="shortcut icon" href="https://helloprogh.github.io/sujinqu/favicon.ico?v=1574263270051">
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
<link rel="stylesheet" href="https://helloprogh.github.io/sujinqu/styles/main.css">

<script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=UA-149251797-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-149251797-1');
</script>


  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://helloprogh.github.io/sujinqu">
  <img class="avatar" src="https://helloprogh.github.io/sujinqu/images/avatar.png?v=1574263270051" alt="">
  </a>
  <h1 class="site-title">
    苏进取
  </h1>
  <p class="site-description">
    凝视深渊
  </p>
  <div class="menu-container">
    
      
        <a href="https://helloprogh.github.io/sujinqu/" class="menu">
          首页
        </a>
      
    
      
        <a href="https://helloprogh.github.io/sujinqu/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="https://helloprogh.github.io/sujinqu/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="https://helloprogh.github.io/sujinqu/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              ECMAScript基础之promise chain
            </h2>
            <div class="post-info">
              <span>
                2019-07-11
              </span>
              <span>
                9 min read
              </span>
              
                <a href="https://helloprogh.github.io/sujinqu/tag/LdAcLxUk" class="post-tag">
                  # promise
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h2 id="前言">前言</h2>
<p>最近因为对 promise 的状态依赖理解有偏差，导致在开发过程中花费了3个小时的时间才发现错误。感觉浪费时间了，所以结合标准及实践结果对 promise 的状态依赖做了一个总结。</p>
<p>问题代码大致是这样的：</p>
<pre><code class="language-javascript">// 假设promise为请求错误回调
 let promise = new Promise((resolve, reject) =&gt; {
    reject('400'); 
 });
 
 // 统一的响应拦截处理
 promise.then((res) =&gt; {
    console.log('promise injector resolved', res) 
 }, (err) =&gt; {
    console.log('promise injector rejected', err) 
 })
 // 请求调用处的业务响应处理
 .then((res) =&gt; {
    console.log('promise resolved', res) 
 }, (err) =&gt; {
    console.log('promise rejected', err) 
 })
 
</code></pre>
<p>上面代码中表现的场景是，错误请求经过请求响应拦截器的统一处理后，业务逻辑本身再根据请求状态来进行一些其他的处理。本来按照我对promise的理解，这样是没有问题的。实际上这里的问题是，业务中的请求响应处理永远只会走成功回调，而不会走失败回调。因为在进行统一的响应拦截处理的时候，就已经丢失了 promise 的状态了。</p>
<h2 id="promise-的三种状态">promise 的三种状态</h2>
<p>promise共有是三种状态：</p>
<ul>
<li>Pending - promise 初始化状态</li>
<li>Fulfilled - 成功</li>
<li>Rejected - 失败</li>
</ul>
<blockquote>
<p>这三种状态是 Promises/A+ 中描述状态的术语</p>
</blockquote>
<p>当我们创建一个 promise 时，它的状态是 Pending，然后随着异步任务的执行，它的状态一定会变成 Fulfilled 和 Rejected 中的一种，且它的状态不会再发生任何变化（这一点很重要，后面捋清楚 promise.then() 的返回值就靠这个特性了）。</p>
<h2 id="promisethen-返回的是一个新的-promise">promise.then() 返回的是一个新的 promise</h2>
<p>先来一代码：</p>
<pre><code class="language-javascript">let promise = Promise.resolve('test');

let thenPromise = promise.then( res =&gt;{
    console.log(res)
});
console.log(promise === thenPromise);
console.log(thenPromise);
</code></pre>
<p>运行结果如下：<br>
<img src="https://user-gold-cdn.xitu.io/2019/7/9/16bd7432c2c0501f?w=329&amp;h=211&amp;f=png&amp;s=16376" alt=""></p>
<p>从运行结果中我们不难得出两点：</p>
<ol>
<li>promise.then() 返回的 promise 和调用 .then() 的 promise 不是同一个</li>
<li>promise.then() 返回的 promise 状态为 resolved，对应本文中描述 promise 状态的 Fulfilled。</li>
</ol>
<p>promise.then() 返回的是一个新的 Promise 的实例对象，而 promise 是能够能表示状态的，这样就可以形成一条状态的依赖链。也就能将多个任务之间的依赖及执行顺序表示出来了，从而将异步任务的回调嵌套转化成为一条扁平的链条。</p>
<h2 id="promise-chain">promise chain</h2>
<p>promise chain 说白了就是个 promise 的调用链，代码形式大致如下：</p>
<pre><code class="language-javascript">var promise1 = Promise.reject('test');
promise1.then(function(res) {
    console.log('fulfilled1', res)
}, function(err) {
    console.log('rejected1', err)
    return err;
}).then(function(res) {
    console.log('fulfilled2', res)
}, function(err) {
    console.log('rejected2', err)
})
</code></pre>
<p>这样的链式调用方式，很好的将多个存在依赖关系的异步任务，将难看回调嵌套转化成了一条更易于理解的扁平链条。从而解决了所谓回调地狱的问题。</p>
<h3 id="promisethen-回调函数的两种返回值">promise.then() 回调函数的两种返回值</h3>
<p>当我们创建了一个 promise 之后，就可以使用 promise.then() 来注册，Fulfilled 和 Rejected 状态对应的执行函数了。类似下面这样：</p>
<pre><code class="language-javascript">var promise = new Promise((resolve, reject)=&gt;{
    resolve('ok');
});
promise.then((res)=&gt;{
    console.log('fulfilled', res)
}, (err)=&gt;{
    console.log('rejected', err)
})
</code></pre>
<p>promise.then() 注册的回调函数可以返回不同的值，分为以下两种：</p>
<ul>
<li>返回除Promise 实例对象以外的任何值</li>
<li>Promise 实例对象</li>
</ul>
<h2 id="promisethen-回调函数返回值对-promise-chain-的影响">promise.then() 回调函数返回值对 promise chain 的影响</h2>
<p>promise.then() 回调函数的返回值决定了其返回的 promise，大致分为以下两种情形：</p>
<ol>
<li>回调函数返回除 Promise 实例对象之外的任何值，决定返回的 promise 注册的回调函数的实参</li>
<li>回调函数返回 Promise 实例对象，决定 promise.then() 返回的 promise 的状态和其注册的回调函数的实参</li>
</ol>
<blockquote>
<p>注意： 这里的回调函数指的是 promise.then() 注册的回调函数，且是指的是被调用的函数，与是成功回调还是失败回调无关</p>
</blockquote>
<h3 id="被执行的回调函数返回除-promise-实例对象之外的任何值">被执行的回调函数返回除 Promise 实例对象之外的任何值</h3>
<p>当 promise.then() 注册的回调函数返回除promise以外的值时，返回的值会被当做 promise.then() 返回的新的 promise 使用 .then() 注册的回调函数的传入值。</p>
<p>当回调函数未返回值时，考虑下面代码：</p>
<pre><code class="language-javascript">let promise = Promise.resolve();
promise.then(()=&gt;{
    console.log('promise resolved')
}, ()=&gt;{
    console.log('promise rejected')
})
.then((value)=&gt;{
    console.log('promise resolved1')
    console.log(value)
}, (err)=&gt;{
    console.log('promise rejected1')
    console.log(err)
})

// promise resolved
// promise resolved1
// undefined

let promise1 = Promise.reject();
promise1.then(()=&gt;{
    console.log('promise1 resolved')
}, ()=&gt;{
    console.log('promise1 rejected')
})
.then((value)=&gt;{
    console.log('promise1 resolved1')
    console.log(value)
}, (err)=&gt;{
    console.log('promise1 rejected1')
    console.log(err)
})

// promise1 rejected
// promise1 resolved1
// undefined
</code></pre>
<p><img src="https://user-gold-cdn.xitu.io/2019/7/11/16be146e8e640d74?w=523&amp;h=126&amp;f=png&amp;s=5874" alt=""><br>
运行结果如上，为了方便阅读结果，我们把打印顺序调换一下，整理如下</p>
<figure data-type="image" tabindex="1"><img src="https://user-gold-cdn.xitu.io/2019/7/11/16be14970be44383?w=354&amp;h=117&amp;f=png&amp;s=4668" alt=""></figure>
<p>promise 注册的回调运行了成功回调，而后返回了一个成功状态的promise，这个返回的 promise 注册的回调运行了成功回调，回调函数的实参是 undefined；promise1 注册的回调运行了失败回调，而后同样返回了一个成功状态的 promise ，这个返回的 promise 注册的回调运行了成功回调，回调函数的实参是 undefined</p>
<blockquote>
<p>js 函数执行后默认返回值为undefined</p>
</blockquote>
<p>再来看看返回其他值的情况：</p>
<pre><code class="language-javascript">let promise = Promise.resolve();
promise.then(()=&gt;{
    console.log('promise resolved')
    return 'value'
}, ()=&gt;{
    console.log('promise rejected')
    return 'err'
})
.then((value)=&gt;{
    console.log('promise resolved1')
    console.log(value)
}, (err)=&gt;{
    console.log('promise rejected1')
    console.log(err)
})
// promise resolved
// promise resolved1
// value

let promise1 = Promise.reject();
promise1.then(()=&gt;{
    console.log('promise1 resolved')
    return 'value'
}, ()=&gt;{
    console.log('promise1 rejected')
    return 'err'
})
.then((value)=&gt;{
    console.log('promise1 resolved1')
    console.log(value)
}, (err)=&gt;{
    console.log('promise1 rejected1')
    console.log(err)
})
// promise1 rejected
// promise1 resolved1
// err
</code></pre>
<p>promise.then() 注册的回调函数，运行的是成功回调，且返回了字符串 “value”，promise.then() 函数返回了一个成功状态的 promise， 返回的 promise 注册的回调函数运行了成功回调，回调函数的实参是字符串“value”；promise1.then() 注册的回调函数，运行的是失败回调，且返回了字符串 “err”，promise1.then() 函数返回了一个成功状态的 promise， 返回的 promise 注册的回调函数运行了成功回调，回调函数的实参是字符串“err”</p>
<p>从上面两段示例代码及其运行结果，不难得出如下结论：</p>
<ol>
<li>当 promise.then() 注册的回调函数返回的不是一个 Promise 示例对象时（代码只示例了返回字符串和undefined的情况，其他情况有兴趣的同学可以验证下返回其他类型的值），promise.then() 返回的是一个 Fulfilled 状态的新的 Promise 实例</li>
<li>这个成功回调的实参就是上一个运行的回调函数的返回值</li>
</ol>
<h3 id="被执行的回调函数返回-promise-实例对象">被执行的回调函数返回 Promise 实例对象</h3>
<p>当 promise.then() 注册的被运行的回调函数返回一个 Promise 实例的时候，回调返回的 Promise 实例的最终的状态会决定 promise.then() 函数返回的这个新的 promise 的状态。且promise.then() 函数返回的 promise 注册的回调函数的实参是由 Promise 实例对象 resolve 或 reject 传递的参数决定的。</p>
<p>考虑如下代码：</p>
<pre><code class="language-javascript">let promiseValue = Promise.reject('promiseValue err');

let promise = Promise.resolve();
let promiseThen = promise.then(()=&gt;{
    console.log('promise resolved');
    return promiseValue;
})
promiseThen.then((res)=&gt;{
    console.log('promise resolved1');
    console.log(res)
}, (err)=&gt;{
    console.log('promise rejected1');
    console.log(err);
})

// promise resolved
// promise rejected1
// promiseValue err

console.log(promiseThen === promiseValue)

// false
</code></pre>
<p>promise 执行成功状态回调，回调函数返回失败状态的 Promise 实例对象 promiseValue，且其 rejecte 传入的值是字符串 “promiseValue err”。因为 promiseValue 的状态是 rejected 所以 promise.then() 返回的新的 Promise 实例（promiseThen === promiseValue 的结果是 false 证明promise.then()返回的）promiseThen 的状态是 rejected，promiseThen 注册的失败回调被调用，打印的实参为字符串“promiseValue err”。</p>
<p>promise.then() 注册的被执行的回调函数返回 Promise 实例对象时：</p>
<ol>
<li>promise.then() 返回一个新的 Promise 实例对象，这个实例对象会等待回调函数返回 Promise 实例对象的状态变成Fulfilled 或 Rejected 中的一种后返回，且状态和回调函数返回 Promise 实例对象的状态一致</li>
<li>promise.then() 返回的 Promise 实例对象，注册的回调函数被执行的时候接受的实参是由回调函数返回 Promise 实例对象传递的结果决定</li>
</ol>
<h2 id="总结">总结</h2>
<p>正是因为 promise.then() 返回的是一个新的 Promise 实例，且这个实例可以向后传递上一个依赖 promise 的异步任务的执行状态和其要传递的数据。这样的链式调用机制，解决了存在依赖关系的异步任务只能在回调函数中不断嵌套的最后导致代码难以维护的问题。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#promise-%E7%9A%84%E4%B8%89%E7%A7%8D%E7%8A%B6%E6%80%81">promise 的三种状态</a></li>
<li><a href="#promisethen-%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AF%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84-promise">promise.then() 返回的是一个新的 promise</a></li>
<li><a href="#promise-chain">promise chain</a>
<ul>
<li><a href="#promisethen-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E4%B8%A4%E7%A7%8D%E8%BF%94%E5%9B%9E%E5%80%BC">promise.then() 回调函数的两种返回值</a></li>
</ul>
</li>
<li><a href="#promisethen-%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E5%AF%B9-promise-chain-%E7%9A%84%E5%BD%B1%E5%93%8D">promise.then() 回调函数返回值对 promise chain 的影响</a>
<ul>
<li><a href="#%E8%A2%AB%E6%89%A7%E8%A1%8C%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E9%99%A4-promise-%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%A4%96%E7%9A%84%E4%BB%BB%E4%BD%95%E5%80%BC">被执行的回调函数返回除 Promise 实例对象之外的任何值</a></li>
<li><a href="#%E8%A2%AB%E6%89%A7%E8%A1%8C%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E-promise-%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1">被执行的回调函数返回 Promise 实例对象</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://helloprogh.github.io/sujinqu/post/ECMAScript基础之变量提升">
              <h3 class="post-title">
                ECMAScript基础之变量提升
              </h3>
            </a>
          </div>
        

        

        <div class="site-footer">
  Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | 
  <a class="rss" href="https://helloprogh.github.io/sujinqu/atom.xml" target="_blank">RSS</a>
</div>

<script>
  hljs.initHighlightingOnLoad()

  let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

  // This should probably be throttled.
  // Especially because it triggers during smooth scrolling.
  // https://lodash.com/docs/4.17.10#throttle
  // You could do like...
  // window.addEventListener("scroll", () => {
  //    _.throttle(doThatStuff, 100);
  // });
  // Only not doing it here to keep this Pen dependency-free.

  window.addEventListener("scroll", event => {
    let fromTop = window.scrollY;

    mainNavLinks.forEach((link, index) => {
      let section = document.getElementById(decodeURI(link.hash).substring(1));
      let nextSection = null
      if (mainNavLinks[index + 1]) {
        nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
      }
      if (section.offsetTop <= fromTop) {
        if (nextSection) {
          if (nextSection.offsetTop > fromTop) {
            link.classList.add("current");
          } else {
            link.classList.remove("current");    
          }
        } else {
          link.classList.add("current");
        }
      } else {
        link.classList.remove("current");
      }
    });
  });

</script>

      </div>
    </div>
  </body>
</html>
